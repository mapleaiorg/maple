//! Reference operator bot that converts governance signals into commitment proposals.
//!
//! This crate does not execute effects directly. It generates proposals that must
//! pass through the WorldLine commitment boundary.

use serde::{Deserialize, Serialize};
use worldline_ledger::{CommitmentClass, CommitmentProposal, EvidenceBundle};
use worldline_types::{CommitmentId, IdentityMaterial, WorldlineId};

/// Snapshot of governance-relevant runtime health.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct OpsSnapshot {
    pub approved_commitments: u64,
    pub denied_commitments: u64,
    pub pending_commitments: u64,
    pub circuit_breaker_active: bool,
    pub evidence_refs: Vec<String>,
}

/// Governance runbooks the operator bot can trigger.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum GovernanceRunbook {
    IncidentResponse,
    PolicyReview,
}

/// Proposal generated by an operator loop.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct BotProposal {
    pub runbook: GovernanceRunbook,
    pub rationale: String,
    pub commitment: CommitmentProposal,
}

/// Policy interface used by the operator loop.
pub trait OperatorPolicy {
    fn evaluate(&self, snapshot: &OpsSnapshot) -> Vec<BotProposal>;
}

/// Default policy: propose incident response on circuit-breaker activation,
/// and policy review when denial ratio exceeds threshold.
#[derive(Clone, Debug)]
pub struct DefaultOperatorPolicy {
    operator_worldline: WorldlineId,
    governance_target: WorldlineId,
    denial_ratio_threshold: f64,
}

impl DefaultOperatorPolicy {
    pub fn new(
        operator_worldline: WorldlineId,
        governance_target: WorldlineId,
        denial_ratio_threshold: f64,
    ) -> Self {
        Self {
            operator_worldline,
            governance_target,
            denial_ratio_threshold,
        }
    }

    pub fn operator_worldline(&self) -> &WorldlineId {
        &self.operator_worldline
    }

    fn proposal(
        &self,
        runbook: GovernanceRunbook,
        intent: String,
        requested_caps: Vec<String>,
        evidence_refs: &[String],
        nonce: u64,
    ) -> BotProposal {
        let commitment = CommitmentProposal {
            worldline: self.operator_worldline.clone(),
            commitment_id: CommitmentId::new(),
            class: CommitmentClass::PolicyChange,
            intent: intent.clone(),
            requested_caps,
            targets: vec![self.governance_target.clone()],
            evidence: EvidenceBundle::from_references(evidence_refs.to_vec()),
            nonce,
        };

        BotProposal {
            runbook,
            rationale: intent,
            commitment,
        }
    }

    /// Construct the governance engine used by operator loops.
    pub fn governance_engine(
        &self,
    ) -> worldline_governance::governance::AgentAccountabilityService {
        worldline_governance::governance::AgentAccountabilityService::new()
    }
}

impl OperatorPolicy for DefaultOperatorPolicy {
    fn evaluate(&self, snapshot: &OpsSnapshot) -> Vec<BotProposal> {
        let mut proposals = Vec::new();
        let mut nonce = 1u64;

        if snapshot.circuit_breaker_active {
            proposals.push(self.proposal(
                GovernanceRunbook::IncidentResponse,
                "circuit breaker active; request incident response runbook".into(),
                vec!["cap-governance-incident".into()],
                &snapshot.evidence_refs,
                nonce,
            ));
            nonce = nonce.saturating_add(1);
        }

        let adjudicated = snapshot
            .approved_commitments
            .saturating_add(snapshot.denied_commitments);

        if adjudicated > 0 {
            let denial_ratio = snapshot.denied_commitments as f64 / adjudicated as f64;
            if denial_ratio >= self.denial_ratio_threshold {
                proposals.push(self.proposal(
                    GovernanceRunbook::PolicyReview,
                    format!(
                        "denial ratio {:.2} exceeds threshold {:.2}",
                        denial_ratio, self.denial_ratio_threshold
                    ),
                    vec!["cap-governance-policy-review".into()],
                    &snapshot.evidence_refs,
                    nonce,
                ));
            }
        }

        proposals
    }
}

/// Operator loop facade that can host alternative policies.
#[derive(Clone, Debug)]
pub struct OperatorBot<P: OperatorPolicy> {
    policy: P,
}

impl<P: OperatorPolicy> OperatorBot<P> {
    pub fn new(policy: P) -> Self {
        Self { policy }
    }

    pub fn run_cycle(&self, snapshot: &OpsSnapshot) -> Vec<BotProposal> {
        self.policy.evaluate(snapshot)
    }
}

impl Default for OperatorBot<DefaultOperatorPolicy> {
    fn default() -> Self {
        let operator_worldline = WorldlineId::derive_with_label(
            &IdentityMaterial::GenesisHash([0x44; 32]),
            "worldline-operator-bot",
        );
        let governance_target = WorldlineId::derive(&IdentityMaterial::GenesisHash([0x99; 32]));
        let policy = DefaultOperatorPolicy::new(operator_worldline, governance_target, 0.30);
        Self::new(policy)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn worldline(seed: u8) -> WorldlineId {
        WorldlineId::derive(&IdentityMaterial::GenesisHash([seed; 32]))
    }

    #[test]
    fn policy_generates_incident_response_when_breaker_is_active() {
        let policy = DefaultOperatorPolicy::new(worldline(1), worldline(2), 0.5);
        let snapshot = OpsSnapshot {
            approved_commitments: 10,
            denied_commitments: 1,
            pending_commitments: 0,
            circuit_breaker_active: true,
            evidence_refs: vec!["obj://ops/incident-42".into()],
        };

        let proposals = policy.evaluate(&snapshot);
        assert_eq!(proposals.len(), 1);
        assert_eq!(proposals[0].runbook, GovernanceRunbook::IncidentResponse);
        assert_eq!(proposals[0].commitment.class, CommitmentClass::PolicyChange);
    }

    #[test]
    fn policy_generates_policy_review_on_high_denial_ratio() {
        let policy = DefaultOperatorPolicy::new(worldline(3), worldline(4), 0.30);
        let snapshot = OpsSnapshot {
            approved_commitments: 7,
            denied_commitments: 3,
            pending_commitments: 2,
            circuit_breaker_active: false,
            evidence_refs: vec!["obj://ops/policy-window".into()],
        };

        let proposals = policy.evaluate(&snapshot);
        assert_eq!(proposals.len(), 1);
        assert_eq!(proposals[0].runbook, GovernanceRunbook::PolicyReview);
        assert!(proposals[0]
            .commitment
            .requested_caps
            .contains(&"cap-governance-policy-review".to_string()));
    }

    #[test]
    fn operator_bot_default_runs_cycle() {
        let bot = OperatorBot::default();
        let snapshot = OpsSnapshot {
            approved_commitments: 1,
            denied_commitments: 0,
            pending_commitments: 0,
            circuit_breaker_active: true,
            evidence_refs: vec!["obj://ops/default".into()],
        };

        let proposals = bot.run_cycle(&snapshot);
        assert_eq!(proposals.len(), 1);
    }

    #[test]
    fn default_policy_exposes_governance_engine() {
        let policy = DefaultOperatorPolicy::new(worldline(8), worldline(9), 0.25);
        let _engine = policy.governance_engine();
    }
}
