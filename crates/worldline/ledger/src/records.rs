use std::collections::BTreeMap;

use serde::{Deserialize, Serialize};
use serde_json::Value;
use worldline_types::{CommitmentId, TemporalAnchor, WorldlineId};

/// Commitment class controls policy tiering at the boundary.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum CommitmentClass {
    ReadOnly,
    ExternalIo,
    FundsMovement,
    PolicyChange,
    OperatorUpgrade,
    Custom(String),
}

/// External evidence references that anchor the commitment.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct EvidenceBundle {
    pub references: Vec<String>,
    pub digest: [u8; 32],
}

impl EvidenceBundle {
    pub fn from_references(references: Vec<String>) -> Self {
        let digest = hash_bytes(&serde_json::to_vec(&references).unwrap_or_default());
        Self { references, digest }
    }
}

/// Commitment proposal generated by a WorldLine operator.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct CommitmentProposal {
    pub worldline: WorldlineId,
    pub commitment_id: CommitmentId,
    pub class: CommitmentClass,
    pub intent: String,
    pub requested_caps: Vec<String>,
    pub targets: Vec<WorldlineId>,
    pub evidence: EvidenceBundle,
    pub nonce: u64,
}

/// Policy decision for a commitment proposal.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum Decision {
    Accepted,
    Rejected { reason: String },
}

impl Decision {
    pub fn is_accepted(&self) -> bool {
        matches!(self, Self::Accepted)
    }

    pub fn is_rejected(&self) -> bool {
        matches!(self, Self::Rejected { .. })
    }
}

/// Immutable commitment receipt stored in WLL.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct CommitmentReceipt {
    pub worldline: WorldlineId,
    pub seq: u64,
    pub receipt_hash: [u8; 32],
    pub prev_hash: Option<[u8; 32]>,
    pub timestamp: TemporalAnchor,
    pub proposal_hash: [u8; 32],
    pub commitment_id: CommitmentId,
    pub class: CommitmentClass,
    pub intent: String,
    pub requested_caps: Vec<String>,
    pub evidence: EvidenceBundle,
    pub decision: Decision,
    pub policy_hash: [u8; 32],
}

/// Human/audit-readable summary of one externally visible effect.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct EffectSummary {
    pub kind: String,
    pub target: String,
    pub description: String,
}

/// Proof reference (artifact stored outside the ledger).
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct ProofRef {
    pub uri: String,
    pub digest: [u8; 32],
}

/// Canonical update applied to projected state.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct StateUpdate {
    pub key: String,
    pub value: Value,
}

/// Input payload for accepted outcomes.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct OutcomeRecord {
    pub effects: Vec<EffectSummary>,
    pub proofs: Vec<ProofRef>,
    pub state_updates: Vec<StateUpdate>,
    pub metadata: BTreeMap<String, String>,
}

impl OutcomeRecord {
    pub fn outcome_hash(&self) -> [u8; 32] {
        let encoded = serde_json::to_vec(self).unwrap_or_default();
        hash_bytes(&encoded)
    }
}

/// Immutable outcome receipt stored in WLL.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct OutcomeReceipt {
    pub worldline: WorldlineId,
    pub seq: u64,
    pub receipt_hash: [u8; 32],
    pub prev_hash: Option<[u8; 32]>,
    pub timestamp: TemporalAnchor,
    pub commitment_receipt_hash: [u8; 32],
    pub outcome_hash: [u8; 32],
    pub accepted: bool,
    pub effects: Vec<EffectSummary>,
    pub proofs: Vec<ProofRef>,
    pub state_updates: Vec<StateUpdate>,
    pub metadata: BTreeMap<String, String>,
}

/// Input payload for snapshot writes.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct SnapshotInput {
    pub worldline: WorldlineId,
    pub anchored_receipt_hash: [u8; 32],
    pub state: BTreeMap<String, Value>,
}

/// Immutable snapshot receipt.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct SnapshotReceipt {
    pub worldline: WorldlineId,
    pub seq: u64,
    pub receipt_hash: [u8; 32],
    pub prev_hash: Option<[u8; 32]>,
    pub timestamp: TemporalAnchor,
    pub anchored_receipt_hash: [u8; 32],
    pub state_hash: [u8; 32],
    pub state: BTreeMap<String, Value>,
}

/// Receipt kind tag for projection and audit code.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum ReceiptKind {
    Commitment,
    Outcome,
    Snapshot,
}

/// Unified receipt envelope for append-only streams.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum Receipt {
    Commitment(CommitmentReceipt),
    Outcome(OutcomeReceipt),
    Snapshot(SnapshotReceipt),
}

/// Compact receipt reference returned by head/index queries.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct ReceiptRef {
    pub worldline: WorldlineId,
    pub seq: u64,
    pub receipt_hash: [u8; 32],
}

impl Receipt {
    pub fn kind(&self) -> ReceiptKind {
        match self {
            Self::Commitment(_) => ReceiptKind::Commitment,
            Self::Outcome(_) => ReceiptKind::Outcome,
            Self::Snapshot(_) => ReceiptKind::Snapshot,
        }
    }

    pub fn worldline(&self) -> &WorldlineId {
        match self {
            Self::Commitment(r) => &r.worldline,
            Self::Outcome(r) => &r.worldline,
            Self::Snapshot(r) => &r.worldline,
        }
    }

    pub fn seq(&self) -> u64 {
        match self {
            Self::Commitment(r) => r.seq,
            Self::Outcome(r) => r.seq,
            Self::Snapshot(r) => r.seq,
        }
    }

    pub fn receipt_hash(&self) -> [u8; 32] {
        match self {
            Self::Commitment(r) => r.receipt_hash,
            Self::Outcome(r) => r.receipt_hash,
            Self::Snapshot(r) => r.receipt_hash,
        }
    }

    pub fn prev_hash(&self) -> Option<[u8; 32]> {
        match self {
            Self::Commitment(r) => r.prev_hash,
            Self::Outcome(r) => r.prev_hash,
            Self::Snapshot(r) => r.prev_hash,
        }
    }

    pub fn timestamp(&self) -> TemporalAnchor {
        match self {
            Self::Commitment(r) => r.timestamp,
            Self::Outcome(r) => r.timestamp,
            Self::Snapshot(r) => r.timestamp,
        }
    }

    pub fn as_commitment(&self) -> Option<&CommitmentReceipt> {
        match self {
            Self::Commitment(r) => Some(r),
            _ => None,
        }
    }

    pub fn as_snapshot(&self) -> Option<&SnapshotReceipt> {
        match self {
            Self::Snapshot(r) => Some(r),
            _ => None,
        }
    }

    pub fn set_receipt_hash(&mut self, hash: [u8; 32]) {
        match self {
            Self::Commitment(r) => r.receipt_hash = hash,
            Self::Outcome(r) => r.receipt_hash = hash,
            Self::Snapshot(r) => r.receipt_hash = hash,
        }
    }
}

impl From<&Receipt> for ReceiptRef {
    fn from(value: &Receipt) -> Self {
        Self {
            worldline: value.worldline().clone(),
            seq: value.seq(),
            receipt_hash: value.receipt_hash(),
        }
    }
}

fn hash_bytes(bytes: &[u8]) -> [u8; 32] {
    *blake3::hash(bytes).as_bytes()
}

#[cfg(test)]
mod tests {
    use super::*;
    use worldline_types::IdentityMaterial;

    fn worldline(seed: u8) -> WorldlineId {
        WorldlineId::derive(&IdentityMaterial::GenesisHash([seed; 32]))
    }

    #[test]
    fn evidence_bundle_generates_digest() {
        let bundle = EvidenceBundle::from_references(vec!["obj://a".into(), "obj://b".into()]);
        assert_ne!(bundle.digest, [0; 32]);
    }

    #[test]
    fn decision_helpers_work() {
        assert!(Decision::Accepted.is_accepted());
        assert!(Decision::Rejected { reason: "x".into() }.is_rejected());
    }

    #[test]
    fn receipt_ref_captures_envelope() {
        let receipt = Receipt::Commitment(CommitmentReceipt {
            worldline: worldline(3),
            seq: 7,
            receipt_hash: [9; 32],
            prev_hash: Some([8; 32]),
            timestamp: TemporalAnchor::new(100, 1, 0),
            proposal_hash: [1; 32],
            commitment_id: CommitmentId::new(),
            class: CommitmentClass::ExternalIo,
            intent: "test".into(),
            requested_caps: vec!["cap".into()],
            evidence: EvidenceBundle::from_references(vec![]),
            decision: Decision::Accepted,
            policy_hash: [2; 32],
        });

        let reference = ReceiptRef::from(&receipt);
        assert_eq!(reference.seq, 7);
        assert_eq!(reference.receipt_hash, [9; 32]);
    }
}
